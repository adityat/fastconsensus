import igraph as ig
import random
from typing import Dict, List
from .algorithms import get_algorithm

def fast_consensus_clustering(graph: ig.Graph, n_partitions: int = 20, threshold: float = 0.2, 
                              max_triads: int = None, algorithm: str = 'louvain',
                              convergence_threshold: float = 0.05, max_iterations: int = 100) -> Dict[int, int]:
    """
    Perform fast consensus clustering on the given graph.

    Problem: Given a graph, find a robust community structure by combining multiple partitions
    generated by a chosen community detection algorithm.

    Approach:
    1. Generate multiple partitions using the specified algorithm.
    2. Construct a sparse consensus matrix based on these partitions.
    3. Apply thresholding to remove weak connections.
    4. Perform triadic closure to enhance community structure.
    5. Repeat steps 1-4 until convergence or max iterations reached.

    :param graph: igraph Graph object
    :param n_partitions: Number of input partitions to generate
    :param threshold: Threshold for consensus matrix entries
    :param max_triads: Maximum number of triads to close (default: number of edges)
    :param algorithm: Name of the community detection algorithm to use
    :param convergence_threshold: Fraction of non-binary entries in consensus matrix to consider converged
    :param max_iterations: Maximum number of iterations before stopping
    :return: Final consensus partition as a dictionary (node_id: community_id)
    :raises ValueError: If the specified algorithm is not supported
    """
    if max_triads is None:
        max_triads = graph.ecount()
    
    community_algorithm = get_algorithm(algorithm)
    consensus_matrix = graph.copy()
    
    # Initialize weights if they don't exist
    if 'weight' not in consensus_matrix.edge_attributes():
        consensus_matrix.es['weight'] = 1.0
    
    for iteration in range(max_iterations):
        print(iteration, end = '\r')
        max_triads = consensus_matrix.ecount()
        # Generate partitions
        partitions = [community_algorithm.detect_communities(consensus_matrix, weight='weight') for _ in range(n_partitions)]
        
        # Construct sparse consensus matrix
        consensus_matrix = construct_sparse_consensus_matrix(consensus_matrix, partitions)
        
        # Thresholding
        consensus_matrix = threshold_matrix(consensus_matrix, threshold)

        # Triadic closure
        consensus_matrix = triadic_closure(consensus_matrix, max_triads, partitions)
        
        # Check for convergence
        if check_convergence(consensus_matrix, convergence_threshold):
            break
    
    # Final partition
    final_partition = community_algorithm.detect_communities(consensus_matrix)
    return final_partition

def construct_sparse_consensus_matrix(previous_matrix: ig.Graph, partitions: List[Dict[int, int]]) -> ig.Graph:
    """
    Construct a new sparse consensus matrix based on the previous iteration's matrix.

    Problem: Create a consensus matrix that represents the agreement between multiple partitions,
    while maintaining the sparsity of the original graph.

    Approach:
    1. Create a copy of the previous matrix.
    2. Reset all edge weights to zero.
    3. For each edge in the previous matrix, calculate the fraction of partitions where
       the connected nodes are in the same community.
    4. Set the edge weight to this fraction.

    :param previous_matrix: igraph Graph object representing the previous consensus matrix
    :param partitions: List of partitions, each represented as a dictionary (node_id: community_id)
    :return: Updated sparse consensus matrix as an igraph Graph object
    """
    n = previous_matrix.vcount()
    new_matrix = previous_matrix.copy()
    new_matrix.es['weight'] = 0.0  # Reset all weights

    # Iterate over existing edges in the previous matrix, not the original graph
    for edge in previous_matrix.es:
        weight = sum(1 for partition in partitions if partition[edge.source] == partition[edge.target])
        if weight > 0:
            new_matrix.add_edge(edge.source, edge.target, weight=weight / len(partitions))

    return new_matrix

def threshold_matrix(consensus_matrix: ig.Graph, threshold: float) -> ig.Graph:
    """
    Apply thresholding to the consensus matrix to remove weak connections.

    Problem: Remove edges with low weights to focus on strong community structures.

    Approach:
    1. Identify edges with weights below the threshold.
    2. Remove these edges from the graph.

    :param consensus_matrix: igraph Graph object representing the consensus matrix
    :param threshold: Minimum weight for an edge to be retained
    :return: Thresholded consensus matrix as an igraph Graph object
    """
    edges_to_remove = [edge.index for edge in consensus_matrix.es if edge['weight'] < threshold]
    consensus_matrix.delete_edges(edges_to_remove)
    return consensus_matrix

def triadic_closure(consensus_matrix: ig.Graph, max_triads: int, input_partitions: List[Dict[int, int]]) -> ig.Graph:
    """
    Perform triadic closure on the consensus matrix to enhance community structure.

    Problem: Strengthen community structure by closing triangles in the graph.

    Approach:
    1. Randomly select nodes and their pairs of neighbors.
    2. If the neighbors are not connected, add an edge between them.
    3. Set the weight of the new edge based on community overlap in input partitions.
    4. Repeat until max_triads is reached or no more triads can be closed.

    :param consensus_matrix: igraph Graph object representing the consensus matrix
    :param max_triads: Maximum number of triads to close
    :param input_partitions: List of input partitions used to calculate edge weights
    :return: Updated consensus matrix with closed triads
    """
    triads_closed = 0
    nodes = list(range(consensus_matrix.vcount()))
    
    for _ in range(max_triads):
        
        node = random.choice(nodes)
        neighbors = consensus_matrix.neighbors(node)
        if len(neighbors) >= 2:
            u, v = random.sample(neighbors, 2)
            if not consensus_matrix.are_connected(u, v):
                # Calculate the weight based on community overlap
                weight = calculate_overlap_weight(u, v, input_partitions)
                consensus_matrix.add_edge(u, v, weight=weight)
                triads_closed += 1
        
    
    #print('triads closed = ', triads_closed)
    return consensus_matrix

def calculate_overlap_weight(u: int, v: int, input_partitions: List[Dict[int, int]]) -> float:
    """
    Calculate the weight of an edge based on community overlap in input partitions.

    Problem: Determine the strength of connection between two nodes based on their
    co-occurrence in the same communities across multiple partitions.

    Approach:
    Count the number of partitions where both nodes are in the same community,
    then divide by the total number of partitions.

    :param u: First node ID
    :param v: Second node ID
    :param input_partitions: List of partitions, each represented as a dictionary (node_id: community_id)
    :return: Calculated weight as a float between 0 and 1
    """
    co_occurrences = sum(1 for partition in input_partitions if partition[u] == partition[v])
    return co_occurrences / len(input_partitions)

def check_convergence(consensus_matrix: ig.Graph, convergence_threshold: float) -> bool:
    """
    Check if the consensus matrix has converged.

    Problem: Determine if the consensus process has reached a stable state.

    Approach:
    1. Count the number of edges with non-binary weights (not 0 or 1).
    2. Calculate the fraction of such edges.
    3. If this fraction is below the convergence threshold, consider it converged.

    :param consensus_matrix: igraph Graph object representing the consensus matrix
    :param convergence_threshold: Fraction of non-binary entries to consider converged
    :return: Boolean indicating whether convergence has been reached
    """
    non_binary_count = sum(1 for edge in consensus_matrix.es if 0 < edge['weight'] < 1)
    return non_binary_count / consensus_matrix.ecount() < convergence_threshold